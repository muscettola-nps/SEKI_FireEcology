---
title: "CedarWestRxDataAnalysis"
author: "Muscettola"
date: "2025-12-07"
output: html_document
---

#R setup

```{r}
#install packages
#install.packages(c("ggplot2", "dplyr", "tidyverse"))
# packages needed for fuel loading analyses
# install.packages("boot")
# install.packages("DT")
# install.packages("emmeans")
# install.packages("flexdashboard")
# install.packages("fs")
# install.packages("ggrepel")
# install.packages("here")
# install.packages("htmltools")
# install.packages("kableExtra")
# install.packages("knitr")
# install.packages("lubridate")
# install.packages("multcomp")
# install.packages("multcompView")
# install.packages("patchwork")
# install.packages("plotly")
# install.packages("purrr")
# install.packages("shiny")
# install.packages("stringr")
# install.packages("stringdist")
#install.packages("xfun")

#load libraries
library(dplyr)
library(tidyverse)
library(ggplot2)
#load libraries for fuel calculations
library(boot)
library(DT)
library(emmeans)
library(fs)
library(flexdashboard)
library(ggrepel)
library(here)
library(htmltools)
library(kableExtra)
library(knitr)
library(lubridate)
library(multcomp)
library(multcompView)
library(patchwork)
library(plotly)
library(purrr)
library(reactable)
library(shiny)
library(stringr)
library(stringdist)

#set working directory
path_data <- "S:/Protection/Fire/Ecology/effects/FireEffects_WorkingFolder/Captain Core Documents/Data_Analysis/Data/2025CedarWestRx/Raw/"
path_out <- "S:/Protection/Fire/Ecology/effects/FireEffects_WorkingFolder/Captain Core Documents/Data_Analysis/Data/2025CedarWestRx/R_working/"

#load data 
FWD_raw <- read.csv(paste0(path_data, "Surface Fuels - Fine_XPT.csv"))
CWD_raw <-read.csv(paste0(path_data, "Surface Fuels - 1000Hr_XPT.csv"))
DuffLitt_raw <- read.csv(paste0(path_data, "Surface Fuels - Duff_Litter_XPT.csv"))
Trees_raw <-read.csv(paste0(path_data, "Trees - Individuals (metric)_XPT.csv"))
Seedlings_raw <- read.csv(paste0(path_data, "Density - Quadrats (metric)_XPT.csv"))
PostBurnSev_raw <- read.csv(paste0(path_data, "Post Burn Severity_XPT.csv"))
```

#Data Tidying
Note: Only do once. After the data is tidied, the code saves the tidy data as a csv so it can be quickly referenced in the future.
##12/7/2025 IM Consider removing non-pertinent columns (i.e. trees remove CrFuBHt:CKR)

###FWD
```{r}
#clean up dataframe 

#clean up date, extract year of the visit, separate MacroPlot.Name into Monitoring Type and Plot Number
FWD <- FWD_raw %>%
  #fix the naming convention of Cedar Plot 1
  mutate(MacroPlot.Name = ifelse(startsWith(MacroPlot.Name, "Cedar"), "B:FPIPO1T09:001", MacroPlot.Name)) %>%
  # Separate MacroPlot.Name to get Monitoring type
  separate(MacroPlot.Name, sep = ":", into = c("BurnType", "MonitoringType", "Plot"), remove = FALSE) %>%
  # Remove relic X column
  select(!X) %>%
  # set column types
  mutate(Plot=as.factor(Plot), Monitoring.Status = factor(Monitoring.Status, levels = c("Pre01", "Post01", "Re01Year01", "Re01Year02", "Re01Year05", "Re01Year10", "Pre02", "Post02", "Re02Year01", "Re02Year05", "Pre03", "Post03")))

#Ensure blanks in visited column are NA
FWD$Visited[FWD$Visited==""] <- NA

# Filter for only data
FWD_data <- FWD %>%
  filter(is.na(Visited))

#Filter for only headers
FWD_header <- FWD %>%
  filter(!is.na(Visited))

rm(FWD, FWD_raw)

```

### CWD
```{r}
#clean up date, extract year of the visit, separate MacroPlot.Name into Monitoring Type and Plot Number
CWD <- CWD_raw %>%
  #fix the naming convention of Cedar Plot 1
  mutate(MacroPlot.Name = ifelse(startsWith(MacroPlot.Name, "Cedar"), "B:FPIPO1T09:001", MacroPlot.Name)) %>%
  # Separate MacroPlot.Name to get Monitoring type
  separate(MacroPlot.Name, sep = ":", into = c("BurnType", "MonitoringType", "Plot"), remove = FALSE) %>%
  # Remove relic X column
  select(!X) %>%
  # set column types
  mutate(Plot=as.factor(Plot), Monitoring.Status = factor(Monitoring.Status, levels = c("Pre01", "Post01", "Re01Year01", "Re01Year02", "Re01Year05", "Re01Year10", "Pre02", "Post02", "Re02Year01", "Re02Year05", "Pre03", "Post03")))

#Ensure blanks in visited column are NA
CWD$Visited[CWD$Visited==""] <- NA

# Filter for only data
CWD_data <- CWD %>%
  filter(is.na(Visited))

#Filter for only headers
CWD_header <- CWD %>%
  filter(!is.na(Visited))

rm(CWD, CWD_raw)
```
### DuffLitt
```{r}
#clean up date, extract year of the visit, separate MacroPlot.Name into Monitoring Type and Plot Number
DuffLitt <- DuffLitt_raw %>%
  #fix the naming convention of Cedar Plot 1
  mutate(MacroPlot.Name = ifelse(startsWith(MacroPlot.Name, "Cedar"), "B:FPIPO1T09:001", MacroPlot.Name)) %>%
  # Separate MacroPlot.Name to get Monitoring type
  separate(MacroPlot.Name, sep = ":", into = c("BurnType", "MonitoringType", "Plot"), remove = FALSE) %>%
  # Remove relic X column
  select(!X) %>%
  # set column types
  mutate(Plot=as.factor(Plot), Monitoring.Status = factor(Monitoring.Status, levels = c("Pre01", "Post01", "Re01Year01", "Re01Year02", "Re01Year05", "Re01Year10", "Pre02", "Post02", "Re02Year01", "Re02Year05", "Pre03", "Post03")))

#Ensure blanks in visited column are NA
DuffLitt$Visited[DuffLitt$Visited==""] <- NA

# Filter for only data
DuffLitt_data <- DuffLitt %>%
  filter(is.na(Visited))

#Filter for only headers
DuffLitt_header <- DuffLitt %>%
  filter(!is.na(Visited))

rm(DuffLitt, DuffLitt_raw)
```
### PostBurnSev
```{r}
#clean up date, extract year of the visit, separate MacroPlot.Name into Monitoring Type and Plot Number
PostBurnSev <- PostBurnSev_raw %>%
  #fix the naming convention of Cedar Plot 1
  mutate(MacroPlot.Name = ifelse(startsWith(MacroPlot.Name, "Cedar"), "B:FPIPO1T09:001", MacroPlot.Name)) %>%
  #Separate Date column into Date and Time columns
  separate(Date, sep = " ", into = c("Date", "Time")) %>%
  separate(Date, sep = "/", into = c("Month", "Day", "Year"), remove = FALSE) %>%
  select(!c("Month", "Day")) %>%
  # Separate MacroPlot.Name to get Monitoring type
  separate(MacroPlot.Name, sep = ":", into = c("BurnType", "MonitoringType", "Plot"), remove = FALSE) %>%
  # Remove relic X column
  select(!X) %>%
  # set column types
  mutate(Plot=as.factor(Plot), Year = as.numeric(Year), Monitoring.Status = factor(Monitoring.Status, levels = c("Pre01", "Post01", "Re01Year01", "Re01Year02", "Re01Year05", "Re01Year10", "Pre02", "Post02", "Re02Year01", "Re02Year05", "Pre03", "Post03")))

#Ensure blanks in visited column are NA
PostBurnSev$Visited[PostBurnSev$Visited==""] <- NA

# Filter for only data
PostBurnSev_data <- PostBurnSev %>%
  filter(is.na(Visited))

#Filter for only headers
PostBurnSev_header <- PostBurnSev %>%
  filter(!is.na(Visited))

rm(PostBurnSev, PostBurnSev_raw)
```
### Seedlings 
```{r}
#clean up date, extract year of the visit, separate MacroPlot.Name into Monitoring Type and Plot Number
Seedlings <- Seedlings_raw %>%
  #fix the naming convention of Cedar Plot 1
  mutate(MacroPlot.Name = ifelse(startsWith(MacroPlot.Name, "Cedar"), "B:FPIPO1T09:001", MacroPlot.Name)) %>%
  #Separate Date column into Date and Time columns
  separate(Date, sep = " ", into = c("Date", "Time")) %>%
  separate(Date, sep = "/", into = c("Month", "Day", "Year"), remove = FALSE) %>%
  select(!c("Month", "Day")) %>%
  # Separate MacroPlot.Name to get Monitoring type
  separate(MacroPlot.Name, sep = ":", into = c("BurnType", "MonitoringType", "Plot"), remove = FALSE) %>%
  # Remove relic X column
  select(!X) %>%
  # set column types
  mutate(Plot=as.factor(Plot), Year = as.numeric(Year), Monitoring.Status = factor(Monitoring.Status, levels = c("Pre01", "Post01", "Re01Year01", "Re01Year02", "Re01Year05", "Re01Year10", "Pre02", "Post02", "Re02Year01", "Re02Year05", "Pre03", "Post03")))

#Ensure blanks in visited column are NA
Seedlings$Visited[Seedlings$Visited==""] <- NA

# Filter for only data
Seedlings_data <- Seedlings %>%
  filter(is.na(Visited))

#Filter for only headers
Seedlings_header <- Seedlings %>%
  filter(!is.na(Visited))

#good! looking at the header, the sampling area for all of the reads is 250m2

rm(Seedlings, Seedlings_raw)
```

### Trees 
```{r}
#clean up date, extract year of the visit, separate MacroPlot.Name into Monitoring Type and Plot Number
Trees <- Trees_raw %>%
  #fix the naming convention of Cedar Plot 1
  mutate(MacroPlot.Name = ifelse(startsWith(MacroPlot.Name, "Cedar"), "B:FPIPO1T09:001", MacroPlot.Name)) %>%
  #Separate Date column into Date and Time columns
  separate(Date, sep = " ", into = c("Date", "Time")) %>%
  separate(Date, sep = "/", into = c("Month", "Day", "Year"), remove = FALSE) %>%
  select(!c("Month", "Day")) %>%
  # Separate MacroPlot.Name to get Monitoring type
  separate(MacroPlot.Name, sep = ":", into = c("BurnType", "MonitoringType", "Plot"), remove = FALSE) %>%
  # Remove relic X column
  select(!X) %>%
  # set column types
  mutate(Plot=as.factor(Plot), Year = as.numeric(Year), Monitoring.Status = factor(Monitoring.Status, levels = c("Pre01", "Post01", "Re01Year01", "Re01Year02", "Re01Year05", "Re01Year10", "Pre02", "Post02", "Re02Year01", "Re02Year05", "Pre03", "Post03")))

#Ensure blanks in visited column are NA
Trees$Visited[Trees$Visited==""] <- NA

# Filter for only data
Trees_data <- Trees %>%
  filter(is.na(Visited))

#Filter for only headers
Trees_header <- Trees %>%
  filter(!is.na(Visited))

rm(Trees, Trees_raw)
```

### Save tidy data as csv's 
```{r}
#save tidy data as csv
#write.csv(FWD_data, paste0(path_out, "CGWestRx_FWD_data.csv"))
#write.csv(FWD_header, paste0(path_out, "CGWestRx_FWD_header.csv"))
#write.csv(CWD_data, paste0(path_out, "CGWestRx_CWD_data.csv"))
#write.csv(CWD_header, paste0(path_out, "CGWestRx_CWD_header.csv"))
#write.csv(DuffLitt_data, paste0(path_out, "CGWestRx_DuffLitt_data.csv"))
#write.csv(DuffLitt_header, paste0(path_out, "CGWestRx_DuffLitt_header.csv"))
#write.csv(PostBurnSev_data, paste0(path_out, "CGWestRx_PostBurnSev_data.csv"))
#write.csv(PostBurnSev_header, paste0(path_out, "CGWestRx_PostBurnSev_header.csv"))
#write.csv(Seedlings_data, paste0(path_out, "CGWestRx_Seedlings_data.csv"))
#write.csv(Seedlings_header, paste0(path_out, "CGWestRx_Seedlings_header.csv"))
#write.csv(Trees_data, paste0(path_out, "CGWestRx_Trees_data.csv"))
#write.csv(Trees_header, paste0(path_out, "CGWestRx_Trees_header.csv"))
```

# Calculating Fuel Loading
12/7/2025 IM - waiting for Nick Kichas for code. Rfuels is not downloading due to newer version of R than allowed. 
12/10/2025 IM - using Nick Kichas code for calculating fuel loads
Github help on fuel loading formulas: https://fisher-j.github.io/multi-age/analysis/calculate_fuel_loading.html
NOTE: the fuel loading constants come from Brown, 1974. https://www.fs.usda.gov/rm/pubs_int/int_gtr016.pdf

###THIS DOESN'T WORK Rfuels setup
```{r}
#install Rfuels package
#install.packages("devtools")
#library(devtools)
#devtools::install_github('danfosterfire/Rfuels')
#install.packages("Rfuels")
#install.packages("Rtools")

#load Rfuels package
#library(Rfuels)
```

### THIS WORKS: Using YELL code

1-100-hr fuels
```{r}
# ---- Function to calculate 1-100-hr fuels for any park dataset ---- #
calculate_ffl_fuels <- function(df) {
  
  # ---- Step 1: Ensure Date is proper datetime format ---- #
  df <- df %>%
    mutate(
      Date = mdy_hms(Date),
      Year = year(Date)
    )
  
  # ---- Step 2: Compute per-transect fuel load ---- #
  transect_level <- df %>%
    mutate(
      d2_1hr = 0.0151,
      d2_10hr = 0.289, 
      d2_100hr = 2.76, 
      s_1hr_10hr = 0.48,
      s_100hr = 0.40,
      a = 1.13,
      c = sqrt(1 + (Slope / 100)^2),
      OneHrTranLen = 6,
      TenHrTranLen = 6,
      HunHrTranLen = 12, 
      OneHr_FuelLoad = (11.64 * OneHr * d2_1hr   * s_1hr_10hr * a * c) / OneHrTranLen,
      TenHr_FuelLoad = (11.64 * TenHr * d2_10hr  * s_1hr_10hr * a * c) / TenHrTranLen,
      HunHr_FuelLoad = (11.64 * HunHr * d2_100hr * s_100hr    * a * c) / HunHrTranLen,
      FuelLoad = OneHr_FuelLoad + TenHr_FuelLoad + HunHr_FuelLoad
    )

  # ---- Step 3: KEEP TRANSECT-LEVEL DATA (do NOT summarise here) ---- #
  plot_level_fine <- transect_level %>%
    mutate(
      Transect_ID = row_number()  # keeps unique transect within plot
    )
}

# --------- For only 1 FWD dataset -------- #
ffl <- calculate_ffl_fuels(FWD_data)  

# Summarize FWD fuel loading according to Monitoring Status #
ffl_summary <- ffl %>%
  group_by(Monitoring.Status) %>%
  summarise(onehr_avg_fl = mean(OneHr_FuelLoad), onehr_min_fl = min(OneHr_FuelLoad), onehr_max_fl = max(OneHr_FuelLoad), onehr_sd_fl = sd(OneHr_FuelLoad), tenhr_avg_fl = mean(TenHr_FuelLoad), tenhr_min_fl = min(TenHr_FuelLoad), tenhr_max_fl = max(TenHr_FuelLoad), tenhr_sd_fl = sd(TenHr_FuelLoad), hunhr_avg_fl = mean(HunHr_FuelLoad), hunhr_min_fl = min(HunHr_FuelLoad), hunhr_max_fl = max(HunHr_FuelLoad), hunhr_sd_fl = sd(HunHr_FuelLoad))

##############USE THIS IF DOING MULTIPLE DATASETS ###
 ## ---- Automatically detect all '_fuels_fine' datasets ---- #
 ## fuel_objs <- ls(pattern = "_fuels_fine$")  # find all objects ending with "_fuels_fine"

# ---- Create a named list of these data objects ---- #
#  fuel_datasets <- mget(fuel_objs)

# ---- Apply function to each dataset and merge ---- #
#  ffl_summary <- imap_dfr(fuel_datasets, ~ {
#    park_code <- str_extract(.y, "^[^_]+")  # extract characters before first underscore
#    calculate_ffl_fuels(.x) %>%
#      mutate(Park = park_code)
#  })

# ---- View merged summary ---- #
#  ffl_summary
```

1000-hr fuel calculations
```{r}
# -------------------------- #
# ---- 1,000-Hour Fuels ---- #
# -------------------------- #

# ---- Function to calculate 1000-hr fuels for any park dataset ---- #
calculate_coarse_fuels <- function(fuels_df, metadata_df) {

  # ---- Step 1: Remove NumTran column from observation data frame ---- #
  fuels_df <- fuels_df %>% select(-NumTran)

  # ---- Step 2: Standardize Dates ---- #
  fuels_df <- fuels_df %>%
    mutate(Date = mdy_hms(Date),
           Year = year(Date))

  metadata_df <- metadata_df %>%
    mutate(Date = mdy_hms(Date),
           Year = year(Date))

  # ---- Step 3: Extract CLEAN metadata (NumTran per plot) ---- #
  metadata_only <- metadata_df %>%
    filter(!is.na(NumTran)) %>%
    distinct(MacroPlot.Name, Monitoring.Status, NumTran)

  # ---- Step 3B: Extract observation rows ----- #
  fuels_df <- fuels_df %>%
    filter(!is.na(DecayCl), !is.na(Dia), !is.na(Transect))
  
  # ---- Step 3C: Bring NumTran into ALL fuels rows ---- #
  fuels_df <- fuels_df %>%
    left_join(metadata_only,
              by = c("MacroPlot.Name", "Monitoring.Status")) %>%
    mutate(
      NumTran = if_else(is.na(NumTran), 1L, NumTran)  # fallback to 1 transect
    )

  # ---- Step 3D: Ensure Transect is numeric BEFORE calculations ---- #
  fuels_df <- fuels_df %>% mutate(
    Transect = suppressWarnings(as.numeric(Transect))
  )
  
  # ---- Step 4: Compute per-log contributions ---- #
  a <- 1.0
  s_sound <- 0.4
  s_rotten <- 0.3
  conversion_factor <- 11.64
  transect_length <- 50

  fuels_processed <- fuels_df %>%
    mutate(
      Transect = suppressWarnings(as.numeric(Transect)),
      DecayCl = suppressWarnings(as.numeric(DecayCl)),
      Dia = suppressWarnings(as.numeric(Dia))
    ) %>%
    filter(DecayCl %in% c(3, 4)) %>%
    mutate(
      D2 = Dia^2,
      s = if_else(DecayCl == 3, s_sound, s_rotten),
      slope_correction = sqrt(1 + (Slope / 100)^2),
      Load = (conversion_factor * D2 * s * a * slope_correction) / transect_length,
      Load_Adjusted = Load / NumTran
    )

  # ---- Step 5A: Create full grid of expected transects per plot/year ---- #
  all_transects <- fuels_df %>%
    distinct(MacroPlot.Name, Monitoring.Status, Year) %>%
    left_join(metadata_only, by = c("MacroPlot.Name", "Monitoring.Status")) %>%
    tidyr::uncount(weights = NumTran, .id = "Transect") %>%
    mutate(Transect = suppressWarnings(as.numeric(Transect)))
  
  # ---- Step 5B: Summarise computed loads (only where logs existed) ---- #
  loads_per_transect <- fuels_processed %>% 
    group_by(MacroPlot.Name, Monitoring.Status, Year, Transect) %>% 
    summarise(
      Decay3_Load     = sum(Load[DecayCl == 3], na.rm = TRUE),
      Decay4_Load     = sum(Load[DecayCl == 4], na.rm = TRUE),
      Coarse_FuelLoad = sum(Load, na.rm = TRUE),
      .groups = "drop"
    ) %>%
    mutate(Transect = suppressWarnings(as.numeric(Transect)))
  
  # ---- Step 5C: Bring zeros back in for missing decay classes ---- #
  fuel_by_transect <- all_transects %>%
    left_join(loads_per_transect,
              by = c("MacroPlot.Name", "Monitoring.Status", "Year", "Transect")) %>%
    mutate(
      Decay3_Load     = replace_na(Decay3_Load, 0),
      Decay4_Load     = replace_na(Decay4_Load, 0),
      Coarse_FuelLoad = replace_na(Coarse_FuelLoad, 0)
    )

  return(fuel_by_transect)
}

## --------- for only one dataset ---------------- ##
CWD_fl <- calculate_coarse_fuels(CWD_data, CWD_header)

#summarize CWD fuel loading by monitoring status
CWD_fl_summary <- CWD_fl %>%
  group_by(Monitoring.Status) %>%
  summarise(Decay3_avg_fl = mean(Decay3_Load), Decay3_min_fl = min(Decay3_Load), Decay3_max_fl = max(Decay3_Load), Decay3_sd_fl = sd(Decay3_Load), Decay4_avg_fl = mean(Decay4_Load), Decay4_min_fl = min(Decay4_Load), Decay4_max_fl = max(Decay4_Load), Decay4_sd_fl = sd(Decay4_Load), Coarse_avg_fl = mean(Coarse_FuelLoad), Coarse_min_fl = min(Coarse_FuelLoad), Coarse_max_fl = max(Coarse_FuelLoad), Coarse_sd_fl = sd(Coarse_FuelLoad))

# ---- Automatically detect all paired '_thousands' datasets ---- #
#  fuels_objs <- ls(pattern = "_fuels_thousands$")
#  metadata_objs <- ls(pattern = "_fuels_thousands_metadata$")

# Identify park codes that exist in both sets
#  parks <- intersect(
#    str_extract(fuels_objs, "^[^_]+"),
#    str_extract(metadata_objs, "^[^_]+")
#  )

# ---- Apply function to each park ---- #
#  coarse_summary <- map_dfr(parks, function(park) {
    
#    fuels_df <- get(paste0(park, "_fuels_thousands"))
#    metadata_df <- get(paste0(park, "_fuels_thousands_metadata"))
    
#    calculate_coarse_fuels(fuels_df, metadata_df) %>%
#      mutate(Park = park)
#})

# ---- View merged summary ---- #
#  coarse_summary
  
################################################################################
################################################################################
################################################################################
```

Duff and Litter 
```{r}
# -------------------------------------- #  
# ---- Litter and Duff Measurements ---- #
# -------------------------------------- #

# ---- Function to calculate litter and duff fuel loads ---- #
calculate_litterduff <- function(fuels_df, metadata_df) {
  
  # ---- Step 1: Remove NumTran column from observation data frame ---- # 
  fuels_df <- DuffLitt_data %>% select(-NumTran)

  # ---- Step 2: Standardize Dates ---- #
  fuels_df <- fuels_df %>%
    mutate(Date = mdy_hms(Date),
           Year = year(Date))

  metadata_df <- DuffLitt_header %>%
    mutate(Date = mdy_hms(Date),
           Year = year(Date))

  # ---- Step 3A: Extract CLEAN metadata (NumTran per plot) ---- #
  metadata_only <- metadata_df %>%
    filter(!is.na(NumTran)) %>%
    distinct(MacroPlot.Name, Monitoring.Status, NumTran)

  # ---- Step 3B: Extract observation rows ----- #
  fuels_df <- fuels_df %>%
    filter(!is.na(LittDep), !is.na(DuffDep), !is.na(Transect))
  
  # ---- Step 3C: Bring NumTran into ALL fuels rows ---- #
  fuels_df <- fuels_df %>%
    left_join(metadata_only,
              by = c("MacroPlot.Name", "Monitoring.Status")) %>%
    mutate(
      NumTran = if_else(is.na(NumTran), 1L, NumTran)  # fallback to 1 transect
    )

  # ---- Step 3D: Ensure Transect is numeric BEFORE calculations ---- #
  fuels_df <- fuels_df %>% mutate(
    Transect = suppressWarnings(as.numeric(Transect))
  )
  
  # ================================ #
  # ==== Bulk density constants ==== #
  # ================================ #

  litter_bd <- 2.75 * 1.815 # FFI default bulk density for litter (2.75)
  duff_bd   <- 5.5  * 1.815 # FFI default bulk density for duff (5.5)
  
  indivpoint_fl <- fuels_df %>%
    mutate(
      Litter_Fuel_indiv = LittDep * litter_bd, 
      Duff_Fuel_indiv = DuffDep * duff_bd,
      Total_Fuel_indiv = Litter_Fuel_indiv + Duff_Fuel_indiv) %>%
    group_by(MacroPlot.Name, Monitoring.Status, Transect) %>%
    summarise(
      Litter_Fuel_indiv = list(indivpoint_fl$Litter_Fuel_indiv),
      Duff_Fuel_indiv = list(indivpoint_fl$Duff_Fuel_indiv),
      Total_Fuel_indiv = list(indivpoint_fl$Total_Fuel_indiv))
  
        # ---- KEEP INDIVIDUAL FUEL VALUES ---- #
      #Litter_Fuel_indiv = list(indivpoint_fl$Litter_Fuel_indiv),
      #Duff_Fuel_indiv = list(indivpoint_fl$Duff_Fuel_indiv),
      #Total_Fuel_indiv = list(indivpoint_fl$Total_Fuel_indiv))
  
  #NOTE: the below code averages by transect - I do not like this because it makes understanding standard deviation difficult. which is why the above code was added^  
  # ---- Step 4: Transect-level averages ---- #
  transect_means <- fuels_df %>%
    group_by(MacroPlot.Name, Monitoring.Status, Year, Transect, NumTran) %>%
    summarise(
      LittDep_tran = mean(LittDep, na.rm = TRUE),
      DuffDep_tran = mean(DuffDep, na.rm = TRUE),
      .groups = "drop"
    ) %>%
    filter(Transect <= NumTran) %>%   # keep only valid transects
    mutate(
      Litter_Fuel_tran = LittDep_tran * litter_bd,
      Duff_Fuel_tran   = DuffDep_tran * duff_bd,
      Total_Fuel_tran  = Litter_Fuel_tran + Duff_Fuel_tran
    )
  
  # ---- Step 5: Plot-level averages ---- #
  plot_means <- transect_means %>%
    group_by(MacroPlot.Name, Monitoring.Status, Year) %>%
    summarise(
      Avg_LittDep = mean(LittDep_tran, na.rm = TRUE),
      Avg_DuffDep = mean(DuffDep_tran, na.rm = TRUE),
  
      # ---- plot-level fuels ---- #
      Litter_Fuel = mean(Litter_Fuel_tran, na.rm = TRUE),
      Duff_Fuel   = mean(Duff_Fuel_tran, na.rm = TRUE),
      Total_Fuel  = mean(Total_Fuel_tran, na.rm = TRUE),
  
      # ---- KEEP TRANSECT FUEL VALUES ---- #
      Litter_Fuel_tran = list(Litter_Fuel_tran),
      Duff_Fuel_tran   = list(Duff_Fuel_tran),
      Total_Fuel_tran  = list(Total_Fuel_tran),
      
      # ---- KEEP INDIVIDUAL FUEL VALUES ---- #
      Litter_Fuel_indiv = list(indivpoint_fl$Litter_Fuel_indiv),
      Duff_Fuel_indiv = list(indivpoint_fl$Duff_Fuel_indiv),
      Total_Fuel_indiv = list(indivpoint_fl$Total_Fuel_indiv),
  
      .groups = "drop"
  )
  
  return(plot_means)
}

# ---------- For only one dataset ------------------ #
DuffLitt_fl <- calculate_litterduff(DuffLitt_data, DuffLitt_header)

#summarise by Monitoring Status
DuffLitt_fl_summary <- DuffLitt_fl %>%
  group_by(Monitoring.Status) %>%
  summarise(Litt_avg_dep = mean(Avg_LittDep), Duff_avg_dep = mean(Avg_DuffDep), Decay3_min_fl = min(Decay3_Load), Decay3__max_fl = max(Decay3_Load), Decay3__sd_fl = sd(Decay3_Load), Decay4__avg_fl = mean(Decay4_Load), Decay4__min_fl = min(Decay4_Load), Decay4__max_fl = max(Decay4_Load), Decay4__sd_fl = sd(Decay4_Load), Coarse_avg_fl = mean(Coarse_FuelLoad), Coarse_min_fl = min(Coarse_FuelLoad), Coarse_max_fl = max(Coarse_FuelLoad), Coarse_sd_fl = sd(Coarse_FuelLoad))

# ---- Automatically detect all paired '_litterduff' datasets ---- #
#  fuels_objs <- ls(pattern = "_fuels_litterduff$")
#  metadata_objs <- ls(pattern = "_fuels_litterduff_metadata$")

# ---- Identify park codes that exist in both sets ---- #
#  parks <- intersect(
#    str_extract(fuels_objs, "^[^_]+"),
#    str_extract(metadata_objs, "^[^_]+")
#  )

# ---- Apply function to each park ---- #
#  litterduff_summary <- map_dfr(parks, function(park) {
    
#    fuels_df <- get(paste0(park, "_fuels_litterduff"))
#    metadata_df <- get(paste0(park, "_fuels_litterduff_metadata"))
    
#    calculate_litterduff(fuels_df, metadata_df) %>%
#      mutate(Park = park)
#})

# ---- View merged summary ---- #
#  litterduff_summary
```

###Reformat


# Fuels Data Visualizations

## FWD

```{r}
#summarize the FWD data by Monitoring Status for all size classes of fuel. This summarizes the minimum, maximum, mean, standard deviation, and standard error for One, Ten, and Hundred hour fuel classes.
FWD_summ <- FWD_data %>%
  group_by(Monitoring.Status) %>%
  reframe(n=n(),
            `Min.`=c(min(OneHr),min(TenHr), min(HunHr)),
            `Max.`=c(max(OneHr),max(TenHr),max(HunHr)),
            `Mean`=c(mean(OneHr),mean(TenHr),mean(HunHr)),
            `SD`=c(sd(OneHr),sd(TenHr),sd(HunHr)),
            `SE`=c(sd(OneHr)/sqrt(n),sd(TenHr)/sqrt(n),sd(HunHr)/sqrt(n)),
            'Size_class'=c("One", "Ten", "Hun"))
```

# Seedlings Data Visualizations

Calculate trees/ac of seedlings
```{r}
# Calculate trees/ac of seedlings knowing that the sampling area was 250m2
#250m2 = 0.0612 ac; 250m2 = 0.025ha
#total area for all 4 plots is 1000m2 (4*250m2)

Seedlings_data <- Seedlings_data %>%
  mutate(TPHa = Count/250*10000, Height_ft = Height * 3.28084, TPA = Count/250*4046.8564) %>%
  mutate(Height = as.factor(Height), Height_ft = as.factor(Height_ft))

Density_all_m <- Seedlings_data %>%
  group_by(Monitoring.Status, Height, Status) %>%
  summarise(Count = sum(Count),
            TPHa = Count/1000*10000) 
#In order to graph by height and status in the same graph we need to create a merged monitoring and live/dead column
#there are no dead seedlings pre burn so let's add a row that has 0 for the TPHa for Dead Pre03
temp <- tibble(Monitoring.Status = as.factor("Pre03"), Height = as.factor("0.15"), Status = "D", Count = 0, TPHa = 0, MonStat = as.factor("Pre03D"))
Density_all_m <- Density_all_m %>%
  mutate(MonStat = paste0(Monitoring.Status, Status)) %>%
  bind_rows(temp) %>%
  mutate(MonStat = factor(MonStat, c("Pre03L", "Pre03D", "Post03L", "Post03D")))


Density_all_ft <- Seedlings_data %>%
  group_by(Monitoring.Status, Height_ft) %>%
  summarise(Count = sum(Count),
            TPA = Count/1000*4046.8564)
#it looks like something weird happened in the counts for Re01Year02 and Re01Year05; very high counts for seedlings <0.15m
```

### Plot Seedling density by size class
```{r}
#metric
a <- ggplot(Density_all_m, aes(x=Monitoring.Status, y=TPHa, fill=Height)) +
  geom_bar(stat = "identity") +
  theme_bw() +
  labs(title = "Seedlings per Ha by Size Class", x = "Monitoring Status", y = "Seedlings/ha")
a

#now let's look only at the most recent burn
b <- ggplot(Density_all_m[36:48, ], aes(x=Monitoring.Status, y=TPHa, fill=Height)) +
  geom_bar(stat = "identity") +
  theme_bw() +
  labs(title = "Pre= and Post- Cedar West Rx: Seedlings per Ha by Size Class", x = "Monitoring Status", y = "Seedlings/ha")
b

#now looking only at the most recent burn, let's include the status of the seedlings (live or dead)
c <- ggplot(Density_all_m[49:66, ], aes(x=MonStat, y=TPHa, fill=Height)) +
  geom_bar(stat = "identity") +
  theme_bw() +
  labs(title = "Pre- and Post- Cedar West Rx: Seedlings per Ha by Size Class", x = "Monitoring Status Live/Dead", y = "Seedlings/ha") + geom_vline(xintercept = 2.5, linetype="dashed", color = "red", linewidth = 0.5)
c
```

###Plot Seedling size classes by species

make summary dataframes for bargraphs
```{r}
Density_sp_m <- Seedlings_data %>%
  group_by(Monitoring.Status, Height, Status, Species.Symbol) %>%
  summarise(Count = sum(Count),
            TPHa = Count/1000*10000) 

Density_all_ft <- Seedlings_data %>%
  group_by(Monitoring.Status, Height_ft, Status, Species.Symbol) %>%
  summarise(Count = sum(Count),
            TPA = Count/1000*4046.8564)
#it looks like something weird happened in the counts for Re01Year02 and Re01Year05; very high counts for seedlings <0.15m
```


```{r}
#dataframe of only Pre03 and Post03
seedlings_prepost03 <- filter(Seedlings_data, Monitoring.Status == "Pre03" | Monitoring.Status == "Post03")
Density_prepost03_m <- filter(Density_sp_m, Monitoring.Status=="Pre03" | Monitoring.Status == "Post03") 

#looking only at the most recent burn, let's include the status of the seedlings (live or dead)

#boxplot
d <- ggplot(Density_prepost03_m, aes(x=Monitoring.Status, y=TPHa, fill=Height)) +
  geom_bar(stat = "identity") +
  facet_wrap(~Species.Symbol) +
  theme_bw() +
  labs(title = "Pre- and Post- Cedar West Rx: Seedlings per Ha by Size Class and Species", x = "Monitoring Status", y = "Seedlings/ha") + geom_vline(xintercept = 1.5, linetype="dashed", color = "red", linewidth = 0.5)
d


```


# Trees Data Visualizations

##Tree Calculations 
NOTE: these calculations include all trees (Dead & Down as well) regardless of whether they all have a measured DBH. It may be worthwhile to exclude dead & down trees for a more "accurate" tree density (trees per ac).
```{r}
#Tree basal area calculation
temp <- Trees_data %>%
  #calculate basal area metric (BA_m2) and imperial (BA_ft2)
  mutate(DBH_in = DBH*0.393701, BA_m2 = pi*(DBH/2)^2/10000, BA_ft2 = pi*(DBH*0.393701/2)^2/144) %>%
  #remove DD trees because the lack of DBH messes with subsequent analyses.
  filter(!is.na(DBH))

#summarise for each monitoring status, plot, and tree status: BA, Trees/ac (or ha), and QMD
Density_trees_all_m <- temp %>%
  group_by(Monitoring.Status,MacroPlot.Name, Status) %>%
  #count instances of L/D trees in each plot (Count), calculate BA per ha of L/D trees in each plot using the individual tree's BA (BA_m2/ha) (area: 50m x 20m = 1000m2 = 0.1ha)
  summarise(Count = n(), BA_m2.ha = sum(BA_m2)/0.1) %>%
  #calculate the trees/ha using the Count and plot size (TPHa), calculate the QMD using the basal area of the stand, trees per ha, and k constant 0.00007854 
  mutate(TPHa = Count/0.1, QMD_cm = sqrt(BA_m2.ha/TPHa/0.00007854))
  
#imperial units
Density_trees_all_ft <- temp %>%
  group_by(Monitoring.Status, MacroPlot.Name, Status) %>%
  #count trees in each plot (Count), calculate BA per ac of L/D tree species in each plot using the individual tree's BA_ft2 (BA_ft2.ac) (area: 50mx20m = 1000m2 = 0.247105)
  summarise(Count = n(), BA_ft2.ac = sum(BA_ft2)/0.247105) %>%
  #calculate the trees/ha using the Count and plot size (TPHa), calculate the QMD using the basal area of the stand, trees per ha, and k constant 0.005454154 
  mutate(TPA = Count/0.247105 , QMD_in = sqrt(BA_ft2.ac/TPA/0.005454154))
  

## Calculate BA, QMD, and Tree density (TPA or TPHa) for each plot, monitoring status, tree status, and species

Density_trees_sp_m <- temp %>%
  group_by(Monitoring.Status,MacroPlot.Name, Status, Species.Symbol) %>%
  #count instances of L/D trees in each plot (Count), calculate BA per ha of L/D trees in each plot using the individual tree's BA (BA_m2/ha) (area: 50m x 20m = 1000m2 = 0.1ha)
  summarise(Count = n(), BA_m2.ha = sum(BA_m2)/0.1) %>%
  #calculate the trees/ha using the Count and plot size (TPHa), calculate the QMD using the basal area of the stand, trees per ha, and k constant 0.00007854 
  mutate(TPHa = Count/0.1, QMD_cm = sqrt(BA_m2.ha/TPHa/0.00007854)) 

#imperial units
Density_trees_sp_ft <- temp %>%
  group_by(Monitoring.Status, MacroPlot.Name, Status, Species.Symbol) %>%
  #count trees in each plot (Count), calculate BA per ac of L/D tree species in each plot using the individual tree's BA_ft2 (BA_ft2.ac) (area: 50mx20m = 1000m2 = 0.247105)
  summarise(Count = n(), BA_ft2.ac = sum(BA_ft2)/0.247105) %>%
  #calculate the trees/ha using the Count and plot size (TPHa), calculate the QMD using the basal area of the stand, trees per ha, and k constant 0.005454154 
  mutate(TPA = Count/0.247105 , QMD_in = sqrt(BA_ft2.ac/TPA/0.005454154)) 


#add an empty row for dead QUKE in Post03 to make graphs prettier
temp2 <- tibble(Monitoring.Status = as.factor("Post03"), Macro.PlotName = "B:FPIPO1T09:001", Status = "D", Species.Symbol ="QUKE1", Count = 0, BA_ft2.ac = 0, TPA = 0, QMD_in = 0)
Density_trees_sp_ft <- bind_rows(Density_trees_sp_ft, temp2)

#subset density to only the most recent pre- and post- read (Pre03 and Post03)
prepost_trees_all_ft <- filter(Density_trees_all_ft, Monitoring.Status == "Pre03" | Monitoring.Status =="Post03") 
prepost_trees_all_m <- filter(Density_trees_all_m, Monitoring.Status == "Pre03" | Monitoring.Status =="Post03") 
prepost_trees_sp_ft <- filter(Density_trees_sp_ft, Monitoring.Status == "Pre03" | Monitoring.Status =="Post03") 
prepost_trees_sp_m <- filter(Density_trees_sp_m, Monitoring.Status == "Pre03" | Monitoring.Status =="Post03") 

```

## Plotting Basal Area

Across all monitoring statuses (full dataset)
```{r}

  
```

Looking only at pre- and post-burn of most recent burn (Cedar West Rx)
```{r}
#plot all trees regardless of species. By status 
t1 <- ggplot(prepost_trees_all_ft, aes(x=Monitoring.Status, y=BA_ft2.ac, fill=Status)) +
  geom_boxplot(position = position_dodge(0.8)) +
  theme_bw() +
  labs(x="Monitoring Status", y = "Basal Area (ft^2/ac)", title = "Pre- and Post- Cedar West Rx: Basal Area by Tree Status") +
  scale_fill_manual(values = c("#665191", "#ffa600"),
                    labels = c("L" = "Live", "D" = "Dead")) + 
  geom_vline(xintercept = 1.5, linetype="dashed", color = "red", linewidth = 0.5)
t1

#now by species of tree
t2 <- ggplot(prepost_trees_sp_ft, aes(x=Monitoring.Status, y=BA_ft2.ac, fill=Status)) +
  geom_boxplot(position = position_dodge(0.8)) +
  theme_bw() +
  labs(x="Monitoring Status", y = "Basal Area (ft^2/ac)", title = "Pre- and Post- Cedar West Rx: Basal Area by Species") +
  scale_fill_manual(values = c("#665191", "#ffa600"),
                    labels = c("L" = "Live", "D" = "Dead")) + 
  geom_vline(xintercept = 1.5, linetype="dashed", color = "red", linewidth = 0.5) + 
  facet_wrap(~Species.Symbol, scales="free_y")
t2
```


## Quadratic Mean Diameter 
looking only at pre- post-burn
```{r}
#plot all trees regardless of species. By status 
t3 <- ggplot(prepost_trees_all_ft, aes(x=Monitoring.Status, y=QMD_in, fill=Status)) +
  geom_boxplot(position = position_dodge(0.8)) +
  theme_bw() +
  labs(x="Monitoring Status", y = "Quadratic Mean Diameter (in)", title = "Pre- and Post- Cedar West Rx: Quadratic Mean Diameter by Tree Status") +
  scale_fill_manual(values = c("#665191", "#ffa600"),
                    labels = c("L" = "Live", "D" = "Dead")) + 
  geom_vline(xintercept = 1.5, linetype="dashed", color = "red", linewidth = 0.5)
t3

#now by species of tree
t4 <- ggplot(prepost_trees_sp_ft, aes(x=Monitoring.Status, y=QMD_in, fill=Status)) +
  geom_boxplot(position = position_dodge(0.8)) +
  theme_bw() +
  labs(x="Monitoring Status", y = "Quadratic Mean Diameter (in)", title = "Pre- and Post- Cedar West Rx: Quadratic Mean Diameter by Species") +
  scale_fill_manual(values = c("#665191", "#ffa600"),
                    labels = c("L" = "Live", "D" = "Dead")) + 
  geom_vline(xintercept = 1.5, linetype="dashed", color = "red", linewidth = 0.5) + 
  facet_wrap(~Species.Symbol, scales="free_y")
t4
```
## Plotting Tree Density (Trees per ac or ha)
```{r}
#plot all trees regardless of species. By status 
t5 <- ggplot(prepost_trees_all_ft, aes(x=Monitoring.Status, y=TPA, fill=Status)) +
  geom_boxplot(position = position_dodge(0.8)) +
  theme_bw() +
  labs(x="Monitoring Status", y = "Trees per Acre", title = "Pre- and Post- Cedar West Rx: Trees per Acre by Tree Status") +
  scale_fill_manual(values = c("#665191", "#ffa600"),
                    labels = c("L" = "Live", "D" = "Dead")) + 
  geom_vline(xintercept = 1.5, linetype="dashed", color = "red", linewidth = 0.5)
t5

#now by species of tree
t6 <- ggplot(prepost_trees_sp_ft, aes(x=Monitoring.Status, y=TPA, fill=Status)) +
  geom_boxplot(position = position_dodge(0.8)) +
  theme_bw() +
  labs(x="Monitoring Status", y = "Trees per Acre", title = "Pre- and Post- Cedar West Rx: Trees per Acre by Species") +
  scale_fill_manual(values = c("#665191", "#ffa600"),
                    labels = c("L" = "Live", "D" = "Dead")) + 
  geom_vline(xintercept = 1.5, linetype="dashed", color = "red", linewidth = 0.5) + 
  facet_wrap(~Species.Symbol, scales="free_y")
t6
```


## Burn Metrics

Here we need to use data from the individual trees (rather than summaries used above). First let's extract only the Pre03 and Post03 trees from the original trees dataset (Trees_data)
```{r}
prepost_indiv_trees <- filter(Trees_data, Monitoring.Status == "Pre03" | Monitoring.Status == "Post03")
```

### Plot Scorch
```{r}
#Scorch Height
## by plot 
s1 <- ggplot(prepost_indiv_trees, aes(x=Plot, y=ScorchHt)) + 
  geom_boxplot() +
  theme_bw() +
  labs(x="Plot Number", y = "Scorch Height (m)", title = "Post- Cedar West Rx: Tree Scorch Height") 
 # scale_fill_manual(values = c("#665191", "#ffa600"),
 #                   labels = c("L" = "Live", "D" = "Dead")) + 
 # geom_vline(xintercept = 1.5, linetype="dashed", color = "red", linewidth = 0.5) + 
 # facet_wrap(~Species.Symbol, scales="free_y")
s1

#Scorch Percentage 


#Height to Live Crown (did the live canopy rise?)

```

